// composables/useAuth.ts
import { ref, computed, onMounted } from "vue";

interface User {
  id: string;
  username: string;
  isFirstLogin: boolean;
  // ÂÖ∂‰ªñÁî®Êà∑‰ø°ÊÅØ
}

export function useAuth() {
  const user = ref<User | null>(null);
  const accessToken = ref<string | null>(null);
  const refreshToken = ref<string | null>(null);
  const loading = ref(false);
  const error = ref<string | null>(null);
  const isRefreshing = ref(false);
  
  // Global promise to prevent race conditions
  let refreshPromise: Promise<string | null> | null = null;
  
  // Get API base URL from runtime config
  const config = useRuntimeConfig();
  const apiBaseUrl = config.public.apiBaseUrl;

  const isLoggedIn = computed(() => !!user.value && !!accessToken.value);

  // ÂÜÖÈÉ® fetch ÂáΩÊï∞Ôºå‰∏ç‰æùËµñ useApi
  async function authFetch(url: string, options: RequestInit = {}) {
    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
      ...(options.headers as Record<string, string> || {}),
    };

    // Â¶ÇÊûúÊúâ tokenÔºåÊ∑ªÂä†Âà∞ headers
    if (accessToken.value) {
      headers['Authorization'] = `Bearer ${accessToken.value}`;
    }

    return fetch(url, {
      ...options,
      headers,
    });
  }

  function safeLocalStorage(
    action: "get" | "set" | "remove",
    key: string,
    value?: string
  ): string | null {
    if (process.client) {
      if (action === "get") {
        return localStorage.getItem(key);
      } else if (action === "set" && value !== undefined) {
        localStorage.setItem(key, value);
        return value;
      } else if (action === "remove") {
        localStorage.removeItem(key);
      }
    }
    return null;
  }

  // Initialize function to check stored tokens
  function init() {
    if (!process.client) return;

    const storedAccessToken = safeLocalStorage("get", "auth_token");
    const storedRefreshToken = safeLocalStorage("get", "refresh_token");
    const storedUserInfo = safeLocalStorage("get", "user_info");

    if (storedAccessToken && storedRefreshToken) {
      accessToken.value = storedAccessToken;
      refreshToken.value = storedRefreshToken;

      // First try to restore from saved user info
      if (storedUserInfo) {
        try {
          const savedUser = JSON.parse(storedUserInfo);
          user.value = savedUser;
          console.log('üë§ Restored user from localStorage:', savedUser.username);
        } catch (e) {
          console.error("Failed to parse stored user info:", e);
        }
      }

      // If no saved user info, parse basic info from access token
      if (!user.value) {
        try {
          const tokenParts = storedAccessToken.split(".");
          if (tokenParts.length === 3) {
            const payload = JSON.parse(atob(tokenParts[1]));
            user.value = {
              id: payload.sub || payload.id,
              username: payload.username || "",
              isFirstLogin: false,
            };
            console.log('üîë Parsed user from token:', user.value.username);
          }
        } catch (e) {
          console.error("Failed to parse token:", e);
        }
      }

      // Validate token and fetch fresh user profile if needed
      try {
        const tokenParts = storedAccessToken.split(".");
        if (tokenParts.length === 3) {
          const payload = JSON.parse(atob(tokenParts[1]));
          const currentTime = Math.floor(Date.now() / 1000);
          
          // If token expires within 5 minutes, refresh it
          if (payload.exp - currentTime < 300) {
            console.log('üîÑ Token expires soon, refreshing...');
            refreshAccessToken().catch(console.error);
          }
        }
      } catch (e) {
        console.error("Failed to check token expiry:", e);
      }

      // Fetch full user profile to ensure data is fresh
      fetchUserProfile(storedAccessToken);
    }
  }

  // Ëé∑ÂèñÁî®Êà∑ËµÑÊñô
  async function fetchUserProfile(authToken: string) {
    if (!process.client) return;
    loading.value = true;

    try {
      // Ëß£Êûê‰ª§ÁâåËé∑ÂèñÁî®Êà∑ID
      let userId = null;
      try {
        const tokenParts = authToken.split(".");
        if (tokenParts.length === 3) {
          const payload = JSON.parse(atob(tokenParts[1]));
          userId = payload.sub || payload.id || user.value?.id;
        }
      } catch (e) {
        console.error("Ëß£Êûê‰ª§ÁâåËé∑ÂèñÁî®Êà∑IDÂ§±Ë¥•", e);
      }

      if (!userId) {
        console.error("Êó†Ê≥ïËé∑ÂèñÁî®Êà∑IDÔºåÊó†Ê≥ïËé∑ÂèñÁî®Êà∑ËµÑÊñô");
        loading.value = false;
        return;
      }

      const response = await authFetch(
        `${apiBaseUrl}/api/users/${userId}`
      );

      if (!response.ok) {
        const errorText = await response.text();
        console.error(`Ëé∑ÂèñÁî®Êà∑ËµÑÊñôÂ§±Ë¥•(${response.status}):`, errorText);
        
        // If unauthorized, don't immediately logout - let useApi handle token refresh
        if (response.status === 401) {
          console.warn("User profile fetch got 401, token may be expired");
          // Don't logout here - this might be normal token expiry
          // The useApi layer will handle token refresh if needed
          return;
        }
        
        error.value = `Ëé∑ÂèñÁî®Êà∑ËµÑÊñôÂ§±Ë¥•(${response.status})`;
        return;
      }

      const userData = await response.json();
      // console.log("Ëé∑ÂèñÁî®Êà∑ËµÑÊñôÊàêÂäü:", userData);

      user.value = {
        id: userData.id || userId,
        username: userData.username || user.value?.username || "",
        isFirstLogin: userData.isFirstLogin || false,
        ...userData,
      };
    } catch (err) {
      console.error("Ëé∑ÂèñÁî®Êà∑ËµÑÊñôÂºÇÂ∏∏:", err);
      error.value = err instanceof Error ? err.message : "Ëé∑ÂèñÁî®Êà∑ËµÑÊñôÂ§±Ë¥•";
    } finally {
      loading.value = false;
    }
  }

  // Êõ¥Êñ∞Áî®Êà∑ËµÑÊñô
  async function updateUserProfile(userData: Partial<User>) {
    if (!process.client || !accessToken.value || !user.value) return null;

    loading.value = true;
    error.value = null;

    try {
      const userId = user.value.id;

      const response = await authFetch(
        `${apiBaseUrl}/api/users/${userId}`,
        {
          method: "PUT",
          body: JSON.stringify(userData),
        }
      );

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        const errorMessage =
          errorData.message || `Êõ¥Êñ∞Áî®Êà∑ËµÑÊñôÂ§±Ë¥•(${response.status})`;
        throw new Error(errorMessage);
      }

      const responseData = await response.json();
      const updatedUserData = responseData.user || responseData;
      user.value = { ...user.value, ...updatedUserData };

      return user.value;
    } catch (err) {
      console.error("Êõ¥Êñ∞Áî®Êà∑ËµÑÊñôÂ§±Ë¥•:", err);
      error.value = err instanceof Error ? err.message : "Êõ¥Êñ∞Áî®Êà∑ËµÑÊñôÂ§±Ë¥•";
      throw err;
    } finally {
      loading.value = false;
    }
  }

  // Token refresh function
  async function refreshAccessToken() {
    console.log('üîÑ Attempting token refresh...', {
      hasRefreshToken: !!refreshToken.value,
      isRefreshing: isRefreshing.value,
      hasExistingPromise: !!refreshPromise
    });
    
    if (!refreshToken.value) {
      console.warn('‚ùå Cannot refresh: missing refresh token');
      return null;
    }

    // If already refreshing, return existing promise
    if (refreshPromise) {
      console.log('üîÑ Token refresh already in progress, waiting...');
      return refreshPromise;
    }
    
    isRefreshing.value = true;
    refreshPromise = (async () => {
      try {
        console.log('üì§ Sending refresh request to:', `${apiBaseUrl}/api/auth/refresh`);
        const response = await fetch(`${apiBaseUrl}/api/auth/refresh`, {
          method: "POST",
          headers: {
            "Authorization": `Bearer ${refreshToken.value}`
          }
        });

        console.log('üì• Refresh response:', {
          status: response.status,
          ok: response.ok,
          statusText: response.statusText
        });

        if (!response.ok) {
          const errorText = await response.text().catch(() => 'Unknown error');
          console.error('‚ùå Refresh failed:', response.status, errorText);
          throw new Error(`Failed to refresh token: ${response.status} ${errorText}`);
        }

        const data = await response.json();
        console.log('‚úÖ Token refresh successful, new token received');
        accessToken.value = data.access_token;
        safeLocalStorage("set", "auth_token", data.access_token);
        
        // Update refresh token if provided
        if (data.refresh_token) {
          refreshToken.value = data.refresh_token;
          safeLocalStorage("set", "refresh_token", data.refresh_token);
        }
        
        return data.access_token;
      } catch (err) {
        console.error("‚ùå Token refresh failed:", err);
        await logout();
        throw err;
      } finally {
        isRefreshing.value = false;
        refreshPromise = null; // Clear the promise
      }
    })();
    
    return refreshPromise;
  }

  // Login function
  async function login(username: string, password: string) {
    loading.value = true;
    error.value = null;

    try {
      const response = await fetch(`${apiBaseUrl}/api/auth/login`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ username, password }),
      });

      if (!response.ok) {
        let errorMessage = "Login failed";
        try {
          const errorData = await response.json();
          errorMessage = errorData.message || errorData.error || errorData.msg || `Login failed (${response.status})`;
        } catch (parseError) {
          const errorText = await response.text();
          errorMessage = `Login failed (${response.status}): ${errorText.substring(0, 100)}`;
        }
        throw new Error(errorMessage);
      }

      const data = await response.json();
      console.log('üîë Login response data:', {
        hasAccessToken: !!data.access_token,
        hasRefreshToken: !!data.refresh_token,
        hasUser: !!data.user,
        dataKeys: Object.keys(data)
      });
      
      accessToken.value = data.access_token;
      refreshToken.value = data.refresh_token;
      user.value = data.user;

      console.log('üíæ Storing tokens in localStorage...');
      safeLocalStorage("set", "auth_token", data.access_token);
      safeLocalStorage("set", "refresh_token", data.refresh_token);
      if (data.user) {
        safeLocalStorage("set", "user_info", JSON.stringify(data.user));
      }
      
      console.log('‚úÖ Tokens stored. Current state:', {
        accessTokenSet: !!accessToken.value,
        refreshTokenSet: !!refreshToken.value,
        userSet: !!user.value
      });

      // Don't auto-redirect here - let the calling page handle redirects
      // This allows for proper "return to previous page" functionality

      return user.value;
    } catch (err) {
      console.error("Login error:", err);
      error.value = err instanceof Error ? err.message : "Login failed, please try again";
      throw err;
    } finally {
      loading.value = false;
    }
  }

  // Logout function
  async function logout() {
    console.log('üö™ Logging out user...');
    loading.value = true;
    error.value = null;

    try {
      if (accessToken.value) {
        console.log('üì§ Sending logout request to server...');
        await authFetch(`${apiBaseUrl}/api/auth/logout`, {
          method: "POST",
        }).catch(console.error);
      }

      console.log('üßπ Clearing auth state and localStorage...');
      user.value = null;
      accessToken.value = null;
      refreshToken.value = null;

      safeLocalStorage("remove", "auth_token");
      safeLocalStorage("remove", "refresh_token");
      safeLocalStorage("remove", "user_info");

      console.log('‚úÖ Logout complete, redirecting to home');
      navigateTo("/");
      return true;
    } catch (err) {
      error.value = err instanceof Error ? err.message : "Logout failed";
      throw err;
    } finally {
      loading.value = false;
    }
  }

  // Register function with email verification
  async function register(username: string, email: string, password: string) {
    loading.value = true;
    error.value = null;

    try {
      console.log("ÂºÄÂßãÊ≥®ÂÜåËØ∑Ê±ÇÔºåÂèëÈÄÅÊï∞ÊçÆ:", { username, email: email || undefined });

      const response = await fetch(`${apiBaseUrl}/api/auth/register`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ 
          username, 
          password,
          email // Email is required for verification
        }),
      });

      console.log("Êî∂Âà∞ÂìçÂ∫îÁä∂ÊÄÅ:", response.status);

      if (!response.ok) {
        let errorMessage = "Ê≥®ÂÜåÂ§±Ë¥•";
        try {
          const errorData = await response.json();
          console.error("ÊúçÂä°Âô®ÈîôËØØËØ¶ÊÉÖ:", errorData);
          
          // Handle specific error messages
          if (errorData.msg === "Username already exists") {
            errorMessage = "ËØ•Áî®Êà∑ÂêçÂ∑≤Ë¢´‰ΩøÁî®ÔºåËØ∑ÈÄâÊã©ÂÖ∂‰ªñÁî®Êà∑Âêç";
          } else if (errorData.msg === "Email already registered") {
            errorMessage = "ËØ•ÈÇÆÁÆ±Â∑≤Ë¢´Ê≥®ÂÜåÔºåËØ∑‰ΩøÁî®ÂÖ∂‰ªñÈÇÆÁÆ±";
          } else if (errorData.msg === "Username is required") {
            errorMessage = "ËØ∑ËæìÂÖ•Áî®Êà∑Âêç";
          } else if (errorData.msg === "Password is required") {
            errorMessage = "ËØ∑ËæìÂÖ•ÂØÜÁ†Å";
          } else if (errorData.msg === "Invalid email format") {
            errorMessage = "ÈÇÆÁÆ±Ê†ºÂºè‰∏çÊ≠£Á°Æ";
          } else if (errorData.msg && errorData.msg.includes("email")) {
            errorMessage = errorData.msg;
          } else {
            errorMessage = errorData.msg || errorData.error || `ÊúçÂä°Âô®ÈîôËØØ(${response.status})`;
          }
        } catch (parseError) {
          const errorText = await response.text();
          console.error("ÊúçÂä°Âô®ËøîÂõûÈùûJSONÈîôËØØ:", errorText);
          errorMessage = `ÊúçÂä°Âô®ÈîôËØØ(${response.status}): ${errorText.substring(0, 100)}`;
        }

        throw new Error(errorMessage);
      }

      const data = await response.json();
      console.log("Ê≥®ÂÜåÊàêÂäüÔºåÊúçÂä°Âô®ÂìçÂ∫î:", data);

      // Return registration data including user_id for email verification
      return { 
        success: true, 
        data,
        userId: data.user_id,
        emailSent: data.email_sent,
        emailError: data.email_error
      };
    } catch (err) {
      console.error("Ê≥®ÂÜåËøáÁ®ã‰∏≠ÂèëÁîüÈîôËØØ:", err);
      error.value = err instanceof Error ? err.message : "Ê≥®ÂÜåÂ§±Ë¥•ÔºåËØ∑Á®çÂêéÂÜçËØï";
      throw err;
    } finally {
      loading.value = false;
    }
  }

  // Email verification function
  async function verifyEmail(userId: number, verificationCode: string) {
    loading.value = true;
    error.value = null;

    try {
      const response = await fetch(`${apiBaseUrl}/api/auth/verify-email`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          user_id: userId,
          verification_code: verificationCode
        }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.msg || "ÈÇÆÁÆ±È™åËØÅÂ§±Ë¥•");
      }

      return { success: true, message: data.msg };
    } catch (err) {
      console.error("ÈÇÆÁÆ±È™åËØÅÈîôËØØ:", err);
      error.value = err instanceof Error ? err.message : "ÈÇÆÁÆ±È™åËØÅÂ§±Ë¥•";
      throw err;
    } finally {
      loading.value = false;
    }
  }

  // Resend verification email
  async function resendVerification(userId: number) {
    loading.value = true;
    error.value = null;

    try {
      const response = await fetch(`${apiBaseUrl}/api/auth/resend-verification`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          user_id: userId
        }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.msg || "ÈáçÂèëÈ™åËØÅÈÇÆ‰ª∂Â§±Ë¥•");
      }

      return { success: true, message: data.msg };
    } catch (err) {
      console.error("ÈáçÂèëÈ™åËØÅÈÇÆ‰ª∂ÈîôËØØ:", err);
      error.value = err instanceof Error ? err.message : "ÈáçÂèëÈ™åËØÅÈÇÆ‰ª∂Â§±Ë¥•";
      throw err;
    } finally {
      loading.value = false;
    }
  }

  // Forgot password function
  async function forgotPassword(email: string) {
    loading.value = true;
    error.value = null;

    try {
      const response = await fetch(`${apiBaseUrl}/api/auth/forgot-password`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ email }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.msg || "ÂèëÈÄÅÈáçÁΩÆÈÇÆ‰ª∂Â§±Ë¥•");
      }

      return { success: true, message: data.msg };
    } catch (err) {
      console.error("ÂøòËÆ∞ÂØÜÁ†ÅÈîôËØØ:", err);
      error.value = err instanceof Error ? err.message : "ÂèëÈÄÅÈáçÁΩÆÈÇÆ‰ª∂Â§±Ë¥•";
      throw err;
    } finally {
      loading.value = false;
    }
  }

  // Reset password function
  async function resetPassword(token: string, newPassword: string) {
    loading.value = true;
    error.value = null;

    try {
      const response = await fetch(`${apiBaseUrl}/api/auth/reset-password`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          token,
          password: newPassword
        }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.msg || "ÂØÜÁ†ÅÈáçÁΩÆÂ§±Ë¥•");
      }

      return { success: true, message: data.msg };
    } catch (err) {
      console.error("ÂØÜÁ†ÅÈáçÁΩÆÈîôËØØ:", err);
      error.value = err instanceof Error ? err.message : "ÂØÜÁ†ÅÈáçÁΩÆÂ§±Ë¥•";
      throw err;
    } finally {
      loading.value = false;
    }
  }

  // Change password function (for authenticated users)
  async function changePassword(currentPassword: string, newPassword: string) {
    loading.value = true;
    error.value = null;

    try {
      const response = await authFetch(`${apiBaseUrl}/api/auth/change-password`, {
        method: "POST",
        body: JSON.stringify({
          current_password: currentPassword,
          new_password: newPassword
        }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.msg || "ÂØÜÁ†Å‰øÆÊîπÂ§±Ë¥•");
      }

      return { success: true, message: data.msg };
    } catch (err) {
      console.error("ÂØÜÁ†Å‰øÆÊîπÈîôËØØ:", err);
      error.value = err instanceof Error ? err.message : "ÂØÜÁ†Å‰øÆÊîπÂ§±Ë¥•";
      throw err;
    } finally {
      loading.value = false;
    }
  }

  // Refresh user data from server
  async function refreshUser() {
    if (!process.client || !accessToken.value || !user.value) return;
    
    console.log('üîÑ Refreshing user data...');
    await fetchUserProfile(accessToken.value);
    
    // Update localStorage with fresh data
    if (user.value) {
      safeLocalStorage("set", "user_info", JSON.stringify(user.value));
    }
  }

  // Âº∫Âà∂Âà∑Êñ∞Áî®Êà∑ËµÑÊñôÊï∞ÊçÆ
  async function forceRefreshUserProfile() {
    if (!process.client || !accessToken.value) return;
    console.log('üîÑ Âº∫Âà∂Âà∑Êñ∞Áî®Êà∑ËµÑÊñô...');
    await fetchUserProfile(accessToken.value);
  }

  // Êõ¥Êñ∞Êú¨Âú∞Áî®Êà∑Êï∞ÊçÆÔºàÁî®‰∫éÁî®Êà∑Âêç‰øÆÊîπÁ≠âÂú∫ÊôØÔºâ
  function updateLocalUserData(updates: Partial<User>) {
    if (!user.value) return;
    
    // Update user data
    user.value = { ...user.value, ...updates };
    
    // Update localStorage
    if (process.client) {
      safeLocalStorage("set", "user_info", JSON.stringify(user.value));
    }
    
    console.log('üë§ Êú¨Âú∞Áî®Êà∑Êï∞ÊçÆÂ∑≤Êõ¥Êñ∞:', updates);
  }

  onMounted(() => {
    init();
  });

  return {
    user,
    token: accessToken,
    accessToken,
    refreshToken,
    loading,
    error,
    isLoggedIn,
    login,
    logout,
    register,
    verifyEmail,
    resendVerification,
    forgotPassword,
    resetPassword,
    changePassword,
    refreshUser,
    init,
    updateUserProfile,
    refreshAccessToken,
    forceRefreshUserProfile,
    updateLocalUserData,
    // ÂØºÂá∫ÂÜÖÈÉ® fetch ÂáΩÊï∞‰æõÂÖ∂‰ªñÂú∞Êñπ‰ΩøÁî®
    authFetch,
  };
}